	c++ programming language	c++ embedded	c++ iso	stroustrup c++	c++ compiler	stroustrup engineering prize	c++ memory management	static storage duration	c++ local variables	objects lifespan	c++ templates	templates vs macro
c++   ˌsiːˌplʌsˈplʌs   is a general purpose programming language created by bjarne stroustrup as an extension of the c programming language  or "c with classes"  the language has expanded significantly over time  and modern c++ has object oriented  generic  and functional features in addition to facilities for low level memory manipulation  it is almost always implemented as a compiled language  and many vendors provide c++ compilers  including the free software foundation  llvm  microsoft  intel  and ibm  so it is available on many platforms 	4.172954	0.593368	0.593368	2.337559	0.593368	1.744191	2.777544	0.000000	0.593368	0.000000	0.593368	0.000000
c++ was designed with a bias toward system programming and embedded  resource constrained software and large systems  with performance  efficiency and flexibility of use as its design highlights  7  c++ has also been found useful in many other contexts  with key strengths being software infrastructure and resource constrained applications  7  including desktop applications  servers  e g  e commerce  web search or sql servers   and performance critical applications  e g  telephone switches or space probes   8 	1.510815	3.652447	0.530252	0.530252	0.530252	0.000000	0.530252	0.000000	0.530252	0.000000	0.530252	0.000000
c++ is standardized by the international organization for standardization  iso   with the latest standard version ratified and published by iso in december 2017 as iso iec 14882:2017  informally known as c++17   9  the c++ programming language was initially standardized in 1998 as iso iec 14882:1998  which was then amended by the c++03  c++11 and c++14 standards  the current c++17 standard supersedes these with new features and an enlarged standard library  before the initial standardization in 1998  c++ was developed by danish computer scientist bjarne stroustrup at bell labs since 1979 as an extension of the c language; he wanted an efficient and flexible language similar to c that also provided high level features for program organization  10  c++20 is the next planned standard  keeping with the current trend of a new version every three years  11 	2.788543	0.516690	5.133165	1.879624	0.516690	1.362934	0.516690	0.000000	0.516690	0.000000	0.516690	0.000000
in 1979  bjarne stroustrup  a danish computer scientist  began work on "c with classes"  the predecessor to c++  12  the motivation for creating a new language originated from stroustrup s experience in programming for his phd  thesis  stroustrup found that simula had features that were very helpful for large software development  but the language was too slow for practical use  while bcpl was fast but too low level to be suitable for large software development  when stroustrup started working in at&t bell labs  he had the problem of analyzing the unix kernel with respect to distributed computing  remembering his ph d  experience  stroustrup set out to enhance the c language with simula like features  13  c was chosen because it was general purpose  fast  portable and widely used  as well as c and simula s influences  other languages also influenced c++  including algol 68  ada  clu and ml 	2.900984	0.417877	0.417877	3.220414	0.417877	2.802537	0.417877	0.000000	0.417877	0.000000	0.417877	0.000000
initially  stroustrup s "c with classes" added features to the c compiler  cpre  including classes  derived classes  strong typing  inlining and default arguments  14 	0.000000	0.000000	0.000000	2.493315	3.590490	2.493315	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000
in 1983  "c with classes" was renamed to "c++"  ++ being the increment operator in c   adding new features that included virtual functions  function name and operator overloading  references  constants  type safe free store memory allocation  new delete   improved type checking  and bcpl style single line comments with two forward slashes       furthermore  it included the development of a standalone compiler for c++  cfront 	0.413525	0.413525	0.413525	0.413525	3.199443	0.000000	2.836146	0.000000	0.413525	0.000000	0.413525	0.000000
in 1985  the first edition of the c++ programming language was released  which became the definitive reference for the language  as there was not yet an official standard  15  the first commercial implementation of c++ was released in october of the same year  12 	3.895335	0.598612	0.598612	0.598612	0.598612	0.000000	0.598612	0.000000	0.598612	0.000000	0.598612	0.000000
in 1989  c++ 2 0 was released  followed by the updated second edition of the c++ programming language in 1991  16  new features in 2 0 included multiple inheritance  abstract classes  static member functions  const member functions  and protected members  in 1990  the annotated c++ reference manual was published  this work became the basis for the future standard  later feature additions included templates  exceptions  namespaces  new casts  and a boolean type 	3.014191	0.611865	0.611865	0.611865	0.611865	0.000000	0.611865	1.677139	0.611865	0.000000	2.461450	1.849585
after the 2 0 update  c++ evolved relatively slowly until  in 2011  the c++11 standard was released  adding numerous new features  enlarging the standard library further  and providing more facilities to c++ programmers  after a minor c++14 update released in december 2014  various new additions were introduced in c++17  and further changes planned for 2020  17 	0.570158	0.570158	0.570158	0.570158	0.570158	0.000000	0.570158	0.000000	0.570158	0.000000	0.570158	0.000000
as of 2017  c++ remains the third most popular programming language  behind java and c  18  19 	3.977565	0.562088	0.562088	0.562088	0.562088	0.000000	0.562088	0.000000	0.562088	0.000000	0.562088	0.000000
on january 3  2018  stroustrup was announced as the 2018 winner of the charles stark draper prize for engineering  "for conceptualizing and developing the c++ programming language"  20 	1.829640	0.517619	0.517619	2.939206	0.517619	10.776757	0.517619	0.000000	0.517619	0.000000	0.517619	0.000000
according to stroustrup: "the name signifies the evolutionary nature of the changes from c"  21  this name is credited to rick mascitti  mid 1983  14  and was first used in december 1983  when mascitti was questioned informally in 1992 about the naming  he indicated that it was given in a tongue in cheek spirit  the name comes from c s ++ operator  which increments the value of a variable  and a common naming convention of using "+" to indicate an enhanced computer program 	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000
during c++ s development period  the language had been referred to as "new c" and "c with classes" 14  22  before acquiring its final name 	2.402709	0.529034	0.529034	0.529034	0.529034	0.000000	0.529034	0.000000	0.529034	0.000000	0.529034	0.000000
as in c  c++ supports four types of memory management: static storage duration objects  thread storage duration objects  automatic storage duration objects  and dynamic storage duration objects  51 	0.517619	0.517619	0.517619	0.517619	0.517619	0.000000	3.550070	9.773220	0.517619	3.407119	0.517619	0.000000
static storage duration objects are created before main   is entered  see exceptions below  and destroyed in reverse order of creation after main   exits  the exact order of creation is not specified by the standard  though there are some rules defined below  to allow implementations some freedom in how to organize their implementation  more formally  objects of this type have a lifespan that "shall last for the duration of the program"  52 	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	6.533640	0.000000	5.181274	0.000000	0.000000
static storage duration objects are initialized in two phases  first  "static initialization" is performed  and only after all static initialization is performed  "dynamic initialization" is performed  in static initialization  all objects are first initialized with zeros; after that  all objects that have a constant initialization phase are initialized with the constant expression  i e  variables initialized with a literal or constexpr   though it is not specified in the standard  the static initialization phase can be completed at compile time and saved in the data partition of the executable  dynamic initialization involves all object initialization done via a constructor or function call  unless the function is marked with constexpr  in c++11   the dynamic initialization order is defined as the order of declaration within the compilation unit  i e  the same file   no guarantees are provided about the order of initialization between compilation units 	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	5.357195	1.330617	2.383024	0.000000	0.000000
variables of this type are very similar to static storage duration objects  the main difference is the creation time is just prior to thread creation and destruction is done after the thread has been joined  53 	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	7.168926	2.289837	2.289837	0.000000	0.000000
the most common variable types in c++ are local variables inside a function or block  and temporary variables  54  the common feature about automatic variables is that they have a lifetime that is limited to the scope of the variable  they are created and potentially initialized at the point of declaration  see below for details  and destroyed in the reverse order of creation when the scope is left  this is implemented by allocation on the stack 	0.384784	0.384784	0.384784	0.384784	0.384784	0.000000	0.384784	0.000000	5.799577	0.000000	0.384784	0.000000
local variables are created as the point of execution passes the declaration point  if the variable has a constructor or initializer this is used to define the initial state of the object  local variables are destroyed when the local block or function that they are declared in is closed  c++ destructors for local variables are called at the end of the object lifetime  allowing a discipline for automatic resource management termed raii  which is widely used in c++ 	0.524456	0.524456	0.524456	0.524456	0.524456	0.000000	3.597103	0.000000	7.686765	0.000000	0.524456	0.000000
member variables are created when the parent object is created  array members are initialized from 0 to the last member of the array in order  member variables are destroyed when the parent object is destroyed in the reverse order of creation  i e  if the parent is an "automatic object" then it will be destroyed when it goes out of scope which triggers the destruction of all its members 	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	2.536756	0.000000	0.000000	0.000000
these objects have a dynamic lifespan and are created with a call to new and destroyed explicitly with a call to delete  55  c++ also supports malloc and free  from c  but these are not compatible with new and delete 	0.476495	0.476495	0.476495	0.476495	0.476495	0.000000	0.476495	0.000000	0.476495	5.439342	0.476495	0.000000
c++ templates enable generic programming  c++ supports function  class  alias and variable templates  templates may be parameterized by types  compile time constants  and other templates  templates are implemented by instantiation at compile time  to instantiate a template  compilers substitute specific arguments for a template s parameters to generate a concrete function or class instance  some substitutions are not possible; these are eliminated by an overload resolution policy described by the phrase "substitution failure is not an error"  sfinae   templates are a powerful tool that can be used for generic programming  template metaprogramming  and code optimization  but this power implies a cost  template use may increase code size  because each template instantiation produces a copy of the template code: one for each set of template arguments  however  this is the same or smaller amount of code that would be generated if the code was written by hand  56  this is in contrast to run time generics seen in other languages  e g   java  where at compile time the type is erased and a single template body is preserved 	1.362380	0.385428	0.385428	0.385428	0.385428	0.000000	0.385428	0.000000	0.385428	0.000000	3.210401	2.824973
templates are different from macros: while both of these compile time language features enable conditional compilation  templates are not restricted to lexical substitution  templates are aware of the semantics and type system of their companion language  as well as all compile time type definitions  and can perform high level operations including programmatic flow control based on evaluation of strictly type checked parameters  macros are capable of conditional control over compilation based on predetermined criteria  but cannot instantiate new types  recurse  or perform type evaluation and in effect are limited to pre compilation text substitution and text inclusion exclusion  in other words  macros can control compilation flow based on pre defined symbols but cannot  unlike templates  independently instantiate new symbols  templates are a tool for static polymorphism  see below  and generic programming 	2.310522	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	1.261391	0.000000	0.000000	2.884158	2.884158
in addition  templates are a compile time mechanism in c++ that is turing complete  meaning that any computation expressible by a computer program can be computed  in some form  by a template metaprogram prior to runtime 	0.489457	0.489457	0.489457	0.489457	0.489457	0.000000	0.489457	0.000000	0.489457	0.000000	2.779294	2.289837
in summary  a template is a compile time parameterized function or class written without knowledge of the specific arguments used to instantiate it  after instantiation  the resulting code is equivalent to code written specifically for the passed arguments  in this manner  templates provide a way to decouple generic  broadly applicable aspects of functions and classes  encoded in templates  from specific aspects  encoded in template parameters  without sacrificing performance due to abstraction 	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	2.517786	2.517786
c++ introduces object oriented programming  oop  features to c  it offers classes  which provide the four features commonly present in oop  and some non oop  languages: abstraction  encapsulation  inheritance  and polymorphism  one distinguishing feature of c++ classes compared to classes in other programming languages is support for deterministic destructors  which in turn provide support for the resource acquisition is initialization  raii  concept 	1.968566	0.556922	0.556922	0.556922	0.556922	0.000000	0.556922	0.000000	0.556922	0.000000	0.556922	0.000000
encapsulation is the hiding of information to ensure that data structures and operators are used as intended and to make the usage model more obvious to the developer  c++ provides the ability to define classes and functions as its primary encapsulation mechanisms  within a class  members can be declared as either public  protected  or private to explicitly enforce encapsulation  a public member of the class is accessible to any function  a private member is accessible only to functions that are members of that class and to functions and classes explicitly granted access permission by the class  "friends"   a protected member is accessible to members of classes that inherit from the class in addition to the class itself and any friends 	0.311505	0.311505	0.311505	0.311505	0.311505	0.000000	0.311505	0.000000	0.311505	0.000000	0.311505	0.000000
the object oriented principle ensures the encapsulation of all and only the functions that access the internal representation of a type  c++ supports this principle via member functions and friend functions  but it does not enforce it  programmers can declare parts or all of the representation of a type to be public  and they are allowed to make public entities not part of the representation of a type  therefore  c++ supports not just object oriented programming  but other decomposition paradigms such as modular programming 	1.814146	0.513236	0.513236	0.513236	0.513236	0.000000	0.513236	0.000000	0.513236	0.000000	0.513236	0.000000
it is generally considered good practice to make all data private or protected  and to make public only those functions that are part of a minimal interface for users of the class  this can hide the details of data implementation  allowing the designer to later fundamentally change the implementation without changing the interface in any way  57  58 	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000
inheritance allows one data type to acquire properties of other data types  inheritance from a base class may be declared as public  protected  or private  this access specifier determines whether unrelated and derived classes can access the inherited public and protected members of the base class  only public inheritance corresponds to what is usually meant by "inheritance"  the other two forms are much less frequently used  if the access specifier is omitted  a "class" inherits privately  while a "struct" inherits publicly  base classes may be declared as virtual; this is called virtual inheritance  virtual inheritance ensures that only one instance of a base class exists in the inheritance graph  avoiding some of the ambiguity problems of multiple inheritance 	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000	0.000000
multiple inheritance is a c++ feature not found in most other languages  allowing a class to be derived from more than one base class; this allows for more elaborate inheritance relationships  for example  a "flying cat" class can inherit from both "cat" and "flying mammal"  some other languages  such as c# or java  accomplish something similar  although more limited  by allowing inheritance of multiple interfaces while restricting the number of base classes to one  interfaces  unlike classes  provide only declarations of member functions  no implementation or member data   an interface as in c# and java can be defined in c++ as a class containing only pure virtual functions  often known as an abstract base class or "abc"  the member functions of such an abstract base class are normally explicitly defined in the derived class  not inherited implicitly  c++ virtual inheritance exhibits an ambiguity resolution feature called dominance 	0.503438	0.503438	0.503438	0.503438	0.503438	0.000000	0.503438	0.000000	0.503438	0.000000	0.503438	0.000000
c++ provides more than 35 operators  covering basic arithmetic  bit manipulation  indirection  comparisons  logical operations and others  almost all operators can be overloaded for user defined types  with a few notable exceptions such as member access    and  *  as well as the conditional operator  the rich set of overloadable operators is central to making user defined types in c++ seem like built in types 	0.552646	0.552646	0.552646	0.552646	0.552646	0.000000	0.552646	0.000000	0.552646	0.000000	0.552646	0.000000
